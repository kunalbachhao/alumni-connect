E-Yantra Robotics Competition
https://www.e-yantra.org/images/slides/4.png
Hereâ€™s a glimpse of the eâ€‘Yantra Robotics Competition (eYRC) â€” a flagship robotics contest by IIT Bombay that uniquely blends learning with competition.

What Is the eâ€‘Yantra Robotics Competition (eYRC)?
Flagship Initiative: Organized annually by IIT Bombay under the eâ€‘Yantra project, this robotics competition is sponsored by the Ministry of Education via the National Mission on Education through ICT (NMEICT). 
Wikipedia
IIT Bombay IRCC

Project-Based Learning (PBL): Teams learn by doingâ€”through mentored challenges mimicking real-world scenarios. 
eyrc24.e-yantra.org
 

MOOC Format: Stage 1 functions as a robotics MOOC, accessible to all registrants. Top performers advance to Stage 2. 
Wikipedia
IIT Bombay IRCC

Themes: Participants receive abstracted, gamified "Themes" tied to issues in domains like agriculture, smart cities, defense, and more. 

Competition Structure:

Duration: 6â€“7 months, spanning two stages. Stageâ€¯1 (simulation/software-based), Stageâ€¯2 (hardware-based tasks). 
IIT Bombay IRCC

Finals: Top teams are invited to showcase their work at IIT Bombay, usually in March. 
Wikipedia
IIT Bombay IRCC

Timeline for eYRC 2024â€“25
Registrations: Open from 1st to 25th August 2024, with early-bird discounts available. 

Stageâ€¯1 (Simulated Tasks): September to November 2024. 

Stageâ€¯2 (Hardware Tasks): November 2024 to February 2025. 

Grand Finale: Held at IIT Bombay on March 28â€“29, 2025. 

Who Can Participate?
Eligibility: Open to full-time Engineering, Science, Polytechnic, or Arts college students globally. Must form teams of 2â€“4 members from the same institution. 


Learning from Scratch: Only basic programming knowledge is needed. eâ€‘Yantra provides training, resources, and mentorship. 


Benefits & Rewards
Hands-On Skill Development: Participants learn areas like ROS, drone control, image processing, embedded systems, FPGA programming, machine learning, control systems, 3D design, remote sensing, functional programming, GIS, and more. 

Prizes:

Cash rewards (often INR 10 lakhs total)

eâ€‘Yantra certificates

Swag and goodies

Paid summer internships at IIT Bombay (typically 6â€“8 weeks) 
à¤­à¤¾à¤°à¤¤à¥€à¤¯ à¤ªà¥à¤°à¥Œà¤¦à¥à¤¯à¥‹à¤—à¤¿à¤•à¥€ à¤¸à¤‚à¤¸à¥à¤¥à¤¾à¤¨ à¤®à¥à¤‚à¤¬à¤ˆ
The Hans India
EdexLive
IIT Bombay IRCC

Community & Innovation: Engage with peers, mentors, and build real-world solutionsâ€”a valued springboard into startups, R&D, and careers. 
IIT Bombay IRCC
Wikipedia
EdexLive

Notable Highlights from Recent Editions
2024â€“25 Winners (SSPU): Second-year Mechatronics team from Symbiosis Skills & Professional University clinched the title, impressing judges with PID-based hardware systems. Final held March 27â€“29, 2025. 
SSPU

2023â€“24 Winners: Another team from the same institution triumphed with a self-balancing bike design. 
SSPU

SCTCE Achievement: A team from SCT College of Engineering, Kerala secured Top 5 in the Warehouse Drone theme, an impressive feat among 834 teams. 
sctcecse.blogspot.com

Why It Stands Out
eYRC transcends traditional robotics competitions by emphasizing learning while competing. Itâ€™s built on a scalable MOOC model enabling hands-on, real-world education even for students with limited resources. 
arXiv
IIT Bombay IRCC

In summary:
Feature	Details
Duration	~6â€“7 months
Structure	Stageâ€¯1 (simulations) â†’ Stageâ€¯2 (hardware) â†’ Finals at IIT Bombay
Eligibility	Full-time students, team of 2â€“4 from same institution
Skills Covered	ROS, embedded systems, ML, FPGA, control systems, etc.
Rewards	Cash prize, internships, certificates, goodies
Goal	Empower practical skill-building, innovation, and readiness for real-world challenges
Interested in joining? Let me know, and I can guide you through registration, preparation strategies, or theme ideas!

You said:
Our Topic is MazeSolver Bot
ChatGPT said:
Great! You're working on the MazeSolver Bot theme in the e-Yantra Robotics Competition. Thatâ€™s a classic and really rich problem â€” good for learning everything from pathfinding algorithms to motor control.

Before we dive in:
ğŸ‘‰ Whatâ€™s your current level with robotics and programming? (Beginner, intermediate, advanced?)
ğŸ‘‰ What platform or tools are you using for this? (Like ROS, Arduino, Firebird V, Python simulation, etc.?)
ğŸ‘‰ Do you have a specific task or challenge right now, or are you looking for general guidance to get started?

Once I know where you're at, we can work together on:

How to approach maze solving (both virtually and with hardware),

Algorithms like DFS, BFS, or the popular left-hand rule and flood-fill,

Line following, sensor calibration, and path optimization.

Letâ€™s start with what you know so far. How would you explain what your MazeSolver Bot is supposed to do?

You said:
Beginner
Only Python
Nope I Want to Learn
ChatGPT said:
Perfect â€” thanks for being clear. Since you're a beginner, using only Python, and just starting to learn, thatâ€™s actually a strong position. Python makes it easy to test logic without worrying (yet) about wires or hardware.

Letâ€™s start small and build up. Here's the plan:

ğŸŒ± Step 1: What is a MazeSolver Bot?
A MazeSolver Bot is a robot (or program) that can navigate through a maze from a start point to an end point.

Letâ€™s break it into two phases:

Maze Understanding â€“ Representing the maze in code.

Maze Solving â€“ Finding a path using logic or an algorithm.

ğŸ§© Quick Check-In:
If I gave you a maze like this:

#########
#S #    #
#  # ## #
#    #  #
###### E#
...what do you think the letters S and E stand for? And how might a robot know where it can move?

Just take a guess â€” we'll build from there.

You said:
Start and End
ChatGPT said:
Exactly right â€” S is the Start, and E is the End.

Now, take a look at the maze again:

#########
#S #    #
#  # ## #
#    #  #
###### E#
All the # symbols are walls, and the spaces are open paths.
The robot can only move on the open paths â€” not through walls.

ğŸ§­ Next Step: How Do We Represent This in Python?
Letâ€™s turn that maze into something a program can understand â€” like a grid of characters.

Hereâ€™s how we can write that in Python (donâ€™t copy this yet â€” just read):

maze = [
    "#########",
    "#S #    #",
    "#  # ## #",
    "#    #  #",
    "###### E#"
]
Now your robot needs to figure out:

Where is S?

How to move from S to E by taking steps up/down/left/right, avoiding #.

ğŸ‘£ Try This:
Can you write a Python function that loops through the maze and prints the row and column of the S (start) position?

If you get stuck, Iâ€™ll help you â€” but give it a shot first.

You said:
actually the website of e-yantra shows FPGA
Verilog
Sensor Integration
Autonomous Navigation
ChatGPT said:
Nice catch. That tells us something really important about your MazeSolver Bot:

You're not just solving a maze in simulation â€” your team will probably have to:

Program real robot hardware (maybe using FPGA and Verilog),

Integrate sensors (like IR or line sensors),

Make the robot autonomously follow and solve the maze.

But since youâ€™re just starting and you only know Python for now â€” thatâ€™s totally okay.

Letâ€™s do this smart:

ğŸ§± Your Learning Path (Beginner â†’ MazeSolver Hero):
Stage 1: Python Simulation (now)
Youâ€™ll build your logic for:

Representing a maze

Finding a path (with algorithms like DFS or BFS)

Simulating the robotâ€™s movements

âœ… This stage builds your algorithmic thinking, which is the core of maze-solving.

Stage 2: Concepts of Sensors and Control
Once you understand how to find a path, we can start learning:

What real-world sensors do

How a robot detects walls or lines

How your Python logic connects to movement in the real world

Stage 3: Hardware & Verilog (optional for now)
This is where FPGA and Verilog come in:

Youâ€™ll move from simulation to real circuits

Verilog is used for hardware-level control (especially on FPGAs)

But even most MazeSolver logic is developed before you go this low-level

So hereâ€™s the key question before we continue:
Would you rather:

Keep going with Python maze-solving first (100% logical),

Or pause and start learning FPGA/Verilog basics now?

Pick one â€” and Iâ€™ll build a path from there.

You said:
Can we use c++ instead of python
ChatGPT said:
Yes â€” and in fact, C++ is often the better choice when working with real robots.

Hereâ€™s why:

âœ… Why C++ Might Be Better for MazeSolver in e-Yantra
Feature	Python	C++
âœ” Easy for beginners	âœ… Yes	ğŸŸ¡ Slightly harder
âœ” Fast execution	âŒ Slower	âœ… Much faster
âœ” Used in embedded systems	âŒ Rarely	âœ… Very common (e.g., Arduino)
âœ” Hardware compatibility	âŒ Needs wrappers (e.g., MicroPython)	âœ… Direct control via libraries
âœ” Used in e-Yantra?	âŒ Mostly for simulation	âœ… Yes, for hardware themes
So if youâ€™re aiming to:

Do sensor integration

Control autonomous navigation

Eventually work with Verilog/FPGA

...then switching to C++ early on is a great idea.

So Letâ€™s Adjust the Plan:
Since you're a beginner, how comfortable are you with C++ basics like:

Variables, loops, conditionals?

Functions?
Quick question for you:
Do you feel comfortable writing loops and functions in C++?
If yes, would you like me to guide you step-by-step to write a simple program that finds the start point in a maze?

You said:
yes

Letâ€™s rewrite the maze using a 2D char array instead.

Step 1: Represent the Maze as a 2D char array
Hereâ€™s how you can store the maze:

#include <iostream>
using namespace std;

int main() {
    char maze[5][10] = {
        "#########",
        "#S #    #",
        "#  # ## #",
        "#    #  #",
        "###### E#"
    };

    // We will add code here to find 'S'

    return 0;
}
Notice:

5 rows (since the maze has 5 lines)

10 columns because each string has 9 characters + 1 for the null terminator \0

Step 2: Write Nested Loops to Find S
Try to write two loops:

Outer loop goes through rows (0 to 4)

Inner loop goes through columns (0 to 8)

Check if maze[row][col] == 'S', then print the coordinates.

Want a quick hint on how to start the loops? Or want me to write the basic skeleton for you?

You said:
for(int i = 0; i< 5; i++)
    {
        for(int j = 0 ; j < 9; j++)
        {
            if(maze[i][j]==S)
            {
                cout<<"Start of Maze Found";
            }
            }
            
        }
    }
consisely format and structure the above data